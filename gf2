#!/bin/bash

shopt -s extglob
shopt -s nocasematch
set -u

# shellcheck disable=SC2086
: ${GF_DATAPATH:=.}
# shellcheck disable=SC2086
: ${GF_CHANGELOG:=CHANGELOG}
# shellcheck disable=SC2086
: ${GF_VERSION:=VERSION}
# shellcheck disable=SC2086
: ${GF_DEV:=dev}
# shellcheck disable=SC2086
: ${GF_ORIGIN:=origin}
# shellcheck disable=SC2086
: ${GF_OPTIONS:=}
# shellcheck disable=SC2086
: ${GF_NOPREFIX:=}
: ${COLUMNS:=$(tput cols)}
: ${LINES:=$(tput lines)}

function main {

  function msg_start {
    [[ $verbose -eq 0 ]] && return
    if stdoutpipe || [[ $COLUMNS -lt 41 ]]; then
      echo -n "$1" && return 0
    fi
    echo -n "[ "
    save_cursor_position
    echo " ....  ] $1"
  }

  function msg_end {
    [[ $verbose -eq 0 ]] && return
    if stdoutpipe || [[ $COLUMNS -lt 41 ]]; then
      echo " [ $1 ]" && return 0
    fi
    set_cursor_position
    echo "$1"
  }

  function stdout_silent {
    [[ $verbose == 0 ]] && exec 5<&1 && exec 1>/dev/null
    return 0
  }

  function stdout_verbose {
    [[ $verbose == 0 ]] && exec 1<&5
    return 0
  }

  function err {
    echo "$(basename "${0}")[error]: $*" >&2
    return 1
  }

  function setcolor {
    local c
    c=${1:-always}
    case $c in
      always|never|auto)
        color=$c
        return 0
      ;;
    esac
    return 2
  }

  function stdoutpipe {
    readlink /proc/$$/fd/1 | grep -q "^pipe:"
  }

  function colorize {
    [[ $color == never ]] && echo -n "$1" && return
    [[ $color == auto ]] && stdoutpipe && echo -n "$1" && return
    local c
    c="${2:-$GREEN}"
    tput setaf "$c"
    echo -n "$1"
    tput sgr0
  }

  function clear_stdin {
    while read -r -t 0; do read -r; done
  }

  function save_cursor_position {
    local curpos oldstty
    curpos="1;1"
    exec < /dev/tty
    oldstty=$(stty -g)
    stty raw -echo min 0
    echo -en "\033[6n" >/dev/tty
    # shellcheck disable=SC2162
    read -d"R" curpos </dev/tty
    stty "$oldstty"
    pos_x=$( echo "${curpos#??}" | cut -d";" -f1 )
    pos_y=$( echo "${curpos#??}" | cut -d";" -f2 )
  }

  function set_cursor_position {
    [[ "$pos_x" == "$LINES" ]] && : $(( pos_x-- ))
    tput cup $(( pos_x-1 )) $(( pos_y-1 ))
  }

  function confirm {
    [[ $yes == 1 ]] && return 0
    if [[ $is_stdin == 0 ]]; then
      stdout_verbose
      echo -n "${1:-"Are you sure?"} [YES/No] "
      save_cursor_position
      clear_stdin
      read -r
      [[ -z "$REPLY" ]] && set_cursor_position && echo "yes"
      stdout_silent
    else
      read -r
    fi
    [[ "$REPLY" =~ ^y(es)?$ || -z "$REPLY" ]] && return 0
    [[ "$REPLY" =~ ^no?$ ]] && return 1
    confirm "Type"
  }

  function git_status_empty {
    [[ -z "$(git status --porcelain)" ]] \
      || err "Uncommitted changes"
  }

  # make git return only error to stderr
  function git_checkout {
    local out
    out="$(git checkout "$@" 2>&1)" \
      || err "$out"
  }

  # make git return only error to stderr
  function git_tag {
    local out
    out="$(git tag "$@" 2>&1)" \
      || err "$out"
  }

  # make git return only error to stderr
  function git_merge {
    local out
    out="$(git merge "$@" 2>&1)" \
      || err "$out"
  }

  function git_push {
    local out
    out="$(git push "$GF_ORIGIN" "$gf_branch" 2>&1)" \
      || err "$out"
  }

  function git_checkout_branch {
    msg_start "Creating branch '$1' on current HEAD"
    git_checkout -b "$1" || return 1
    msg_end "$DONE"
  }

  function git_branch_create {
    local to
    to="${2:-HEAD}"
    msg_start "Creating branch '$1' on '$to'"
    git branch "$1" "$to"
    msg_end "$DONE"
  }

  function git_branch_exists {
    git rev-parse --verify "$1" >/dev/null 2>&1 && return 0
    git rev-parse --verify "$GF_ORIGIN/$1" >/dev/null 2>&1 \
      && git branch "$1" "$GF_ORIGIN/$1" >/dev/null 2>&1 || return 1
  }

  function git_tag_here {
    git tag --points-at HEAD | grep -q "^$1$"
  }

  function git_repo_exists {
    [[ -d .git ]]
  }

  function git_remote_exists {
    git config remote."$GF_ORIGIN".url >/dev/null \
      || err "Remote url for '$GF_ORIGIN' does not exist" \
      || return 1
  }

  function git_remote_branch_exists {
    local branch
    branch=${1:-$gf_branch}
    msg_start "Checking if '$branch' exists on remote '$GF_ORIGIN'"
    git ls-remote --heads "$GF_ORIGIN" | grep -q "$REFSHEADS/$branch"$ \
      || err "Remote branch '$branch' does not exist" \
      || return 1
    msg_end "$DONE"
  }

  function git_commit_diff {
    [[ "$( git rev-parse "$1" )" != "$( git rev-parse "$2" )" ]]
  }

  function git_version_diff {
    [[ "$(git show "$1":"$GF_VERSION" | cut -d. -f1-2)" != "$2" ]]
  }

  function git_current_branch {
    git rev-parse --abbrev-ref HEAD
  }

  function git_stash {
    git_status_empty 2>/dev/null && return 0
    msg_start "Stashing files"
    git add -A >/dev/null || return 1
    git stash >/dev/null || return 1
    # shellcheck disable=SC2015
    git_status_empty 2>/dev/null \
      && { stashed=1; msg_end "$DONE"; } \
      || { msg_end "$FAILED"; return 1; }
  }

  function git_stash_pop {
    [[ $stashed == 0 ]] && return 0
    msg_start "Popping stashed files"
    git stash pop >/dev/null || { msg_end "$FAILED"; return 1; }
    msg_end "$DONE"
  }

  function git_has_commits {
    git log >/dev/null 2>&1
  }

  function load_version {
    [[ -f "$GF_VERSION" ]] \
      || err "Version file not found" \
      || return 3
    [[ -n "$(cat "$GF_VERSION")" ]] \
      || err "Version file is empty" \
      || return 3
    [[ "$(cat "$GF_VERSION")" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] \
      || err "Invalid version file content format" \
      || return 1
    IFS=. read -r major minor patch < "$GF_VERSION" \
      || err "Unable to load version" \
      || return 1
    master=$prefix$major.$minor
  }

  function master_last_change {
    git cherry -v "$GF_DEV" master | tail -n1 | cut -d" " -f2
  }

  function init_file {
    [[ -s "$1" ]] && return 0 # file exists and is not empty
    [[ $conform == 1 ]] \
      || err "Missing or empty file '$1'" \
      || return 3
    local message
    message="Initializing '$1' file"
    msg_start "$message"
    echo "$2" > "$1" || return 1
    git add "$1" >/dev/null \
      && git commit -m "$message" >/dev/null \
      || return 1
    msg_end "$DONE"
  }

  function initial_commit {
    git_status_empty 2>/dev/null && return 0
    msg_start "Initial commit"
    git add -A >/dev/null \
      && git commit -m "Commit initial files" >/dev/null \
      || err "Unable to commit existing files" \
      || return 1
    msg_end "$DONE"
  }

  # 1) validate repository existence
  # 2) validate repository consistency:
  # - at least one commit
  # - master branch
  function validate_git_repository {
    if ! git_repo_exists; then
      [[ $conform == 0 ]] && { err "Git repository does not exist" || return 3; }
      msg_start "Initializing git repository"
      git init >/dev/null || return 1
      msg_end "$DONE"
    fi
    if ! git_has_commits; then
      [[ $conform == 0 ]] && { err "Git repository without commits" || return 3; }
      initial_commit || return $?
    elif ! git_branch_exists master; then
      [[ $conform == 0 ]] && { err "Missing branch 'master'" || return 3; }
      git_branch_create master || return 1
    fi
  }

  # validate $GF_VERSION and $GF_HANGELOG files
  function validate_gf_files {
    init_file "$GF_VERSION" "0.0.0" \
      && init_file "$GF_CHANGELOG" "$GF_CHANGELOG created" \
      && load_version \
      || return $?
  }

  # validate tag on ($)master
  function validate_master_tag {
    if ([[ $1 == master ]] || [[ $1 == "$master" ]]) && ! git_tag_here "$master.$patch"; then
      [[ $conform == 0 ]] && { err "Missing tag '$master.$patch' on current HEAD" || return 3; }
      git_tag "$master.$patch";
    fi
  }

  # 1) validate $GF_DEV branch
  # 2) validate $GF_DEV is up to date with master
  function validate_dev {
    if ! git_branch_exists "$GF_DEV"; then
      [[ $conform == 0 ]] && { err "Missing branch '$GF_DEV'" || return 3; }
      git_branch_create dev master || return 1
    fi
    local last_change
    last_change="$(master_last_change)"
    if [[ -n "$last_change" ]] && ! git branch --contains "$last_change" | grep -q "$GF_DEV"; then
      [[ $conform == 0 ]] && { err "Branch master is not merged with '$GF_DEV'" || return 3; }
      merge_branches "$last_change" "$GF_DEV" || return $?
    fi
  }

  # validate git status
  function validate_status_empty {
    if [[ $force == 1 ]]; then
      git_stash || return $?
    else
      git_status_empty || return 4
    fi
  }

  function gf_validate {
    validate_git_repository
    validate_gf_files
    local gcb
    gcb="$(git_current_branch)"
    validate_master_tag "$gcb"
    validate_dev
    validate_status_empty
    # load and validate user params
    if [[ $arg_count -gt 1 ]]; then
      par_kw="$par1"
      par_name="$par2"
      is_gf_keyword "$par_kw" \
        || err "Parameter '$par_kw' is not a valid keyword" \
        || return 1
    elif [[ $arg_count == 1 ]]; then
      is_gf_keyword "$par1" \
        && par_kw="$par1" \
        || par_name="$par1"
    fi
    [[ -z "$par_name" ]] && return 0
    git check-ref-format "$REFSHEADS/$par_name" \
      || err "Invalid branch name format" \
      || return 1
  }

  function is_gf_keyword {
    [[ "$1" == "$HOTFIX" || "$1" == "$RELEASE" || "$1" == "$FEATURE" ]]
  }

  # Get free branch name (increment suffix)
  # Eg. when branch "$HOTFIX-john" and "$HOTFIX-john-1" already exists
  # then for param "$HOTFIX-john" return "$HOTFIX-john-2"
  function get_branch_name {
    local count
    local branch
    branch="$1"
    count="${2:-}"
    [[ -z "$count" ]] \
      && ! git_branch_exists "$branch" \
      && echo "$branch" \
      && return
    [[ -z "$count" ]] && count=1
    git_branch_exists "$branch-$count" \
      && get_branch_name "$branch" $(( ++count )) \
      || echo "$branch-$count"
  }

  # TODO algo?
  function prefix_branch {
    local kw name
    kw="${1:-}"
    name="${2:-}"
    [[ -n "$kw" ]] \
      || err "prefix_branch: missing kw param" \
      || return 1
    [[ "$name" == "$kw-"* ]] \
      && echo "$name" \
      && return
    # [[ "$name" == "$kw" ]] ?
    [[ -z "$name" ]] && name="$(id -u -n | tr '[:upper:]' '[:lower:]')"
    get_branch_name "$kw-$name"
  }

  function gf_checkout {
    [[ "$(git_current_branch)" == "$1" ]] \
      && gf_branch="$(git_current_branch)" \
      && return 0
    # assume checkout to tag or branch
    git_checkout "$1" \
      && gf_validate \
      && load_version \
      || return $?
    gf_branch="$(git_current_branch)"
    msg_end "$DONE"
  }

  function gf_process_params {
    # eg. for "gf hotfix aaa" checkout to "hotfix-aaa"
    if [[ $arg_count -gt 1 ]] && git_branch_exists "$par_kw-$par_name"; then
      gf_checkout "$par_kw-$par_name" || return $?
      return
    fi
    # eg. for "gf hotfix-aaa" checkout to "hotfix-aaa"
    if [[ $arg_count == 1 ]] && git_branch_exists "$par_name"; then
      gf_checkout "$par_name" || return $?
      return
    fi
    # action according to given kw
    if [[ -n "$par_kw" ]]; then
      case "$par_kw" in
        $HOTFIX) gf_hotfix "$par_name" ;;
        $FEATURE) gf_feature "$par_name" ;;
        $RELEASE)
          [[ -z "$par_name" ]] \
            || err "Parameter '$par_name' does not make any sense with kw '$RELEASE'" \
            || return 1
          gf_release
        ;;
      esac
      return $?
    fi
    # action according to current branch
    case "${gf_branch%%-*}" in
      $HOTFIX) ;; # TODO merge_hotfix ($par_name -> ignore or error)
      master|$prefix+([0-9]).+([0-9])) ;; # TODO create_hotfix $par_name
      $RELEASE) ;; # TODO merge_release ($par_name -> error)
      $GF_DEV) ;; # TODO create_release (empty $par_name) OR create_feature $par_name
      $FEATURE) ;; # TODO merge_feature ($par_name -> ignore or error)
      *) err "Current branch '$gf_branch' is not recognized" || return 1 ;;
    esac
    #par_name="$(prefix_branch "$par_kw" "$par_name")"
  }

  # TODO create or proceed feature
  # $1 optional feature name
  function gf_feature {
    :
  }
  # TODO create or proceed hotfix
  # $1 optional hotfix name
  function gf_hotfix {
    :
  }
  # TODO create or proceed release
  function gf_release {
    :
  }


  # variables
  local line script_name master force conform yes verbose dry what_now color prefix pos_x pos_y init request is_stdin gf_branch major minor patch
  what_now=0
  dry=0
  verbose=0
  yes=0
  script_name="gf"
  prefix="$([ -z "$GF_NOPREFIX" ] && echo v)"
  major=0
  minor=0
  patch=0
  master=${prefix}0.0
  color=auto
  pos_x=1
  pos_y=1
  [ -t 0 ]
  is_stdin=$?
  newfeature=0
  gf_branch="$(git_current_branch)"

  # process options
  # shellcheck disable=SC2086
  # shellcheck disable=SC2048
  if ! line=$(
    IFS=" " getopt -n "$0" \
           -o cfhinrvVwy\? \
           -l conform,color::,colour::,force,help,init,dry-run,request,verbose,version,what-now,yes \
           -- $GF_OPTIONS $*
  )
  then gf_usage; return 2; fi
  eval set -- "$line"

  # load user options
  force=0
  conform=0
  init=0
  request=0
  while [ $# -gt 0 ]; do
    case $1 in
     -c|--conform) conform=1; shift ;;
     --color|--colour) shift; setcolor "$1" || { gf_usage; return 2; }; shift ;;
     -f|--force) force=1; shift ;;
     -h|-\?|--help) gf_usage; return $? ;;
     -i|--init) init=1; conform=1; shift ;;
     -n|--dry-run) dry=1; shift ;;
     -r|--request) request=1; shift;;
     -v|--verbose) verbose=1; shift ;;
     -V|--version) gf_version; return $? ;;
     -w|--what-now) what_now=1; shift ;;
     -y|--yes) yes=1; shift ;;
      --) shift; break ;;
      *-) echo "$script_name: Unrecognized option '$1'" >&2; gf_usage; return 2 ;;
       *) break ;;
    esac
  done

  # constants
  local -r \
    RED=1 \
    GREEN=2 \
    BLUE=4 \
    GITHUB="github.com" \
    BITBUCKET="bitbucket.org" \
    HOTFIX="hotfix" \
    RELEASE="release" \
    FEATURE="feature" # TODO $GF_{HOTFIX,RELEASE,FEATURE} ?
  local -r \
    REFSHEADS="refs/heads" \
    DONE="$(colorize "  ok  " $GREEN)" \
    FAILED="$(colorize "failed" $RED)" \
    SKIPPED="$(colorize "skipped" $BLUE)"

  # proceed params
  local par1 par2 par_kw par_name arg_count
  par1="${1:-}"
  par2="${2:-}"
  par_kw=
  par_name=
  arg_count=$#

  # # silent output by default
  # stdout_silent
  # # dry run
  # [[ $dry == 1 ]] && { gf_what_now; return 0; }


  # shellcheck disable=SC2015
  gf_validate && gf_process_params || {
    case $? in
      1) err "Generic error occurred (see REPORTING BUGS)."; return 1 ;;
      # 3) err "Git is not conform with OMGF model (see conform option)."; return 3 ;;
      # 4) err "Git status is not empty (see force option)."; return 4 ;;
      # 5) err "Git conflict occurred (see 'git status')."; gf_what_now; return 5 ;;
    esac
  }


  # # proceed gf
  # # shellcheck disable=SC2015
  # gf_validate && gf_prepare && {
  #   if [[ $newfeature == 0 ]]; then load_version && gf_run; fi
  #   } && git_stash_pop && gf_what_now || {
  #   case $? in
  #     1) err "Generic error occurred (see REPORTING BUGS)."; return 1 ;;
  #     3) err "Git is not conform with OMGF model (see conform option)."; return 3 ;;
  #     4) err "Git status is not empty (see force option)."; return 4 ;;
  #     5) err "Git conflict occurred (see 'git status')."; gf_what_now; return 5 ;;
  #   esac
  # }


}

main "$@"