#!/bin/bash

function main {

  function takeClean {
    [[ $verbose == 1 ]] && clear
    [[ $verbose == 1 ]] && echo "### test $1"
    [[ $verbose == 0 ]] && echo -n "#$1 "
    cd "$currentdir"
    rm -rf "$1"
    mkdir -p "$1"
    cd "$1"
  }
  function ll {
    [[ $verbose == 0 ]] && return 0
    echo "# directory listing:"
    echo "$sep"
    ls -lA
    echo
  }
  function gla {
    [[ $verbose == 1 ]] \
      && echo "# git log:" \
      && echo "$sep"
    log="$(git --no-pager log --oneline --decorate --graph --all)"
    IFS=$'\n' read -d '' -r -a loglines <<< "$log"
    [[ $verbose == 0 ]] && return
    echo "$log"
    echo
  }
  function gref {
    if [[ $verbose == 1 ]]; then
      echo "# git show-ref:"
      echo "$sep"
    fi
    ref="$(git show-ref)"
    firsthash="$(echo "$ref" | head -n1 | cut -d" " -f1)"
    [[ $verbose == 0 ]] && return 0
    echo "$ref"
    echo
  }
  function gs {
    [[ $verbose == 0 ]] && return 0
    echo "# git status:"
    echo "$sep"
    git status
    echo
  }
  function testHeader {
    echo "$1"
    [[ $verbose == 0 ]] || echo "$sep"
  }
  function debug {
    local c
    [[ $verbose == 1 ]] && echo "# cmd: $1"
    eval "$1" > /tmp/gftesttmpout 2>&1
    c=$?
    output="$(cat /tmp/gftesttmpout)"
    [[ $verbose == 1 ]] && echo "$output"
    IFS=$'\n' read -d '' -r -a lines <<< "$output"
    [[ $verbose == 0 ]] && return $c
    echo
    echo "# status code:"
    echo $sep
    echo "$c"
    echo
    return $c
  }
  function confirm {
    local msg
    msg="${1:-"Are you sure?"}"
    [[ $verbose == 0 ]] && return 0
    echo -n "$msg [YES/No] "
    read -r
    [[ "$REPLY" =~ ^[yY](es)?$ || -z "$REPLY" ]] && return 0
    [[ "$REPLY" =~ ^[nN]o?$ ]] && return 1
    confirm "Type"
  }
  function startTest {
    [[ $((++i)) -gt $skip ]] || return 1
    confirm "Run test '$1'?" || return 1
    : $((runned++))
    takeClean "$i"
    testHeader "test $1"
  }
  function status {
    if [[ $verbose == 1 ]]; then
      local s
      s="$ok"
      echo -n "[ "
      [[ $1 != 0 ]] && s="$fail"
      echo -n "$s"
      echo -n " ] "
    fi
    if [[ $1 != 0 ]]; then
      : $((failed++))
      tput setaf 1 \
        && echo "${FUNCNAME[1]}:" \
        && echo "arg1:" \
        && echo "$2" \
        && echo "arg2:" \
        && echo "$3" \
        && tput sgr0
    elif [[ $verbose == 1 ]]; then
      echo "${FUNCNAME[1]} ..."
    fi
    return $1
  }
  function assert_equal {
    [[ "$1" == "$2" ]]
    status $? "$1" "$2"
  }
  function assert_startwith {
    [[ "$1" == "$2"* ]]
    status $? "$1" "$2"
  }
  function assert_contains {
    echo "$1" | grep -q "$2"
    status $? "$1" "$2"
  }
  function checkInitRefs {
    assert_equal $(echo "$ref" | wc -l) 3
    assert_equal $(echo "$ref" | grep $firsthash | wc -l) 3
    assert_contains "$ref" "refs/heads/dev"
    assert_contains "$ref" "refs/heads/master"
    assert_contains "$ref" "refs/tags/v0.0.0"
  }
  function checkInitFiles {
    assert_equal "$(cat VERSION)" "0.0.0"
    assert_equal "$(cat CHANGELOG)" "CHANGELOG created"
  }
  function gsp {
    git status --porcelain
  }
  function git_current_branch {
    git rev-parse --abbrev-ref HEAD
  }
  function changelog {
    chglog="$(cat CHANGELOG)"
    [[ $verbose == 1 ]] \
      && echo "# changelog:" \
      && echo "$sep" \
      && echo "$chglog"
    IFS=$'\n' read -d '' -r -a chgloglines <<< "$chglog"
  }

  local currentdir sep skip i output lines ok fail failed ref firsthash log loglines runned verbose changelog chglines

  currentdir="$(pwd)"
  sep="-----------"
  i=0
  runned=0
  output=
  lines=()
  log=
  loglines=()
  chglog=
  chgloglines=()
  failed=0
  ok="$(tput setaf 2; echo -n "  ok  "; tput sgr0)"
  fail="$(tput setaf 1; echo -n fail; tput sgr0)"

  if ! line=$(
    IFS=" " getopt -n "$0" \
           -o v \
           -l verbose \
           -- $*
  )
  then return 2; fi
  eval set -- "$line"

  # load user options
  verbose=0
  while [ $# -gt 0 ]; do
    case $1 in
     -v|--verbose) verbose=1; shift ;;
      --) shift; break ;;
      *-) echo "$script_name: Unrecognized option '$1'" >&2; return 2 ;;
       *) break ;;
    esac
  done

  skip="${1:-0}"

  export GF_OPTIONS=""
  export COLUMNS=30

#######################################
## Integration
#######################################
  if startTest "gf help"; then
    debug "gf --help 2>/dev/null"
    assert_equal $? 0
    assert_startwith "${lines[0]}" "Usage: gf [-"
  fi
#######################################
  if startTest "gf version"; then
    debug "gf --version"
    assert_equal $? 0
    assert_startwith "${lines[0]}" "GNU gf "
  fi
#######################################
  if startTest "man gf"; then
    debug "man 2>/dev/null gf"
    assert_equal $? 0
    assert_startwith "${lines[0]}" "GF(1)"
  fi
#######################################
## Error codes
#######################################
  if startTest "invalid option error code"; then
    debug "gf --invalid-option"
    assert_equal $? 2
    #assert_startwith "${lines[0]}" "getopt: unknown"
    assert_startwith "${lines[1]}" "Usage: gf [-"
  fi
#######################################
  if startTest "missing git error code"; then
    debug "gf"
    assert_equal $? 3
    assert_startwith "${lines[0]}" "gf[error]: Git repository does not exist"
  fi
#######################################
  if startTest "missing branch dev error code"; then
    { gf -i \
      && git checkout master \
      && git branch -d dev
    } >/dev/null 2>&1
    debug "gf"
    assert_equal $? 3
    assert_startwith "${lines[0]}" "gf[error]: Missing branch 'dev'"
  fi
#######################################
  if startTest "missing VERSION file error code"; then
    { gf -i \
      && rm VERSION \
      && git commit -am "delete VERSION file"
    } >/dev/null
    debug "gf"
    assert_equal $? 3
    assert_startwith "${lines[0]}" "gf[error]: Missing or empty file 'VERSION'"
  fi
#######################################
  if startTest "dev is behind master error code"; then
    { gf -i \
      && echo a > a \
      && git add a \
      && git commit -am "add file a" \
      && gf --yes \
      && gf --yes \
      && git reset --hard HEAD~1
    } >/dev/null
    debug "gf -v"
    assert_equal $? 3
    assert_startwith "${lines[0]}" "gf[error]: Branch master is not merged with 'dev'"
  fi
#######################################
  if startTest "uncommitted changes error code"; then
    { gf -i \
      && echo a > a
    } >/dev/null
    debug "gf"
    assert_equal $? 4
    assert_startwith "${lines[0]}" "gf[error]: Uncommitted changes"
  fi
#######################################
  if startTest "conflicting merge error code"; then
    { gf -i \
      && gf --yes hotfix \
      && git checkout dev 2>&1 \
      && echo 1.0.0 > VERSION \
      && git commit -am "bump version"
    } >/dev/null
    debug "gf --yes hotfix"
    assert_equal $? 5
    assert_startwith "${lines[0]}" "gf[error]: Auto-merging"
  fi
#######################################
## Dry run
#######################################
  if startTest "dry run"; then
    debug "gf --dry-run"
    assert_equal $? 0
  fi
#######################################
  if startTest "dry run and invalid option"; then
    debug "gf --dry-run --invalid-option"
    assert_equal $? 2
    #assert_startwith "${lines[0]}" "getopt: unknown"
    assert_startwith "${lines[1]}" "Usage: gf [-"
  fi
#######################################
## Init
#######################################
  if startTest "init on empty folder"; then
    debug "gf -v --init"
    assert_equal $? 0
    checkInitFiles
    gla
    gref
    checkInitRefs
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "init on non-empty folder"; then
    { echo a > a \
      && echo b > b \
      && echo test > .gitignore
    } >/dev/null
    ll
    debug "gf -v --init"
    assert_equal $? 0
    checkInitFiles
    gla
    gref
    checkInitRefs
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "init on existing repo with commits"; then
    { git init \
      && echo a > a \
      && git add . \
      && git commit -am "first commit.."
    } >/dev/null
    gla
    debug "gf -v --init"
    assert_equal $? 0
    checkInitFiles
    gla
    gref
    checkInitRefs
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "init on existing repo without commits"; then
    { git init \
      && echo a > a
    } >/dev/null
    gs
    debug "gf -v --init"
    assert_equal $? 0
    checkInitFiles
    gla
    gref
    checkInitRefs
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "init on existing repo with commits and --force"; then
    { git init \
      && echo a > a \
      && git add . \
      && git commit -am "first commit" \
      && echo b > b
    } >/dev/null
    gla
    gs
    debug "gf -v --init --force"
    assert_equal $? 0
    checkInitFiles
    gla
    gref
    checkInitRefs
    gs
    assert_equal "$(gsp | wc -l)" 1
  fi
#######################################
## Conform
#######################################
  if startTest "conform on empty folder"; then
    debug "yes no | gf -v --conform"
    assert_equal $? 0
    checkInitFiles
    gla
    gref
    checkInitRefs
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "conform on non-empty folder"; then
    { echo a > a \
      && echo b > b \
      && echo test > .gitignore
    } >/dev/null
    ll
    debug "yes no | gf -v --conform"
    assert_equal $? 0
    checkInitFiles
    gla
    gref
    checkInitRefs
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "conform on existing repo with commits"; then
    { git init \
      && echo a > a \
      && git add . \
      && git commit -am "first commit.."
    } >/dev/null
    gla
    debug "yes no | gf -v --conform"
    assert_equal $? 0
    checkInitFiles
    gla
    gref
    checkInitRefs
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "conform on existing repo without commits"; then
    { git init \
      && echo a > a
    } >/dev/null
    gs
    debug "yes no | gf -v --conform"
    assert_equal $? 0
    checkInitFiles
    gla
    gref
    checkInitRefs
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "conform on existing repo with commits and --force"; then
    { git init \
      && echo a > a \
      && git add . \
      && git commit -am "first commit" \
      && echo b > b
    } >/dev/null
    gla
    gs
    debug "yes no | gf -v --conform --force"
    assert_equal $? 0
    checkInitFiles
    gla
    gref
    checkInitRefs
    gs
    assert_equal "$(gsp | wc -l)" 1
  fi
#######################################
## Feature
#######################################
  if startTest "create feature"; then
    { gf --init; } >/dev/null
    gla
    debug "gf -v --yes myfeature"
    assert_equal $? 0
    assert_startwith "${lines[0]}" "Creating branch 'myfeature'"
    gref
    assert_contains "$ref" "refs/heads/myfeature"
    gla
    assert_equal "$(git_current_branch)" "myfeature"
    gs
  fi
#######################################
  if startTest "create feature with uncommited changes and --force"; then
    { gf --init \
      && echo a > a
    } >/dev/null
    gla
    debug "gf -v --yes --force myfeature"
    assert_equal $? 0
    assert_startwith "${lines[0]}" "Stashing files"
    gla
    assert_equal "$(git_current_branch)" "myfeature"
    gs
    assert_equal "$(gsp)" "A  a"
  fi
#######################################
  if startTest "merge feature"; then
    { gf --init \
      && gf --yes myfeature \
      && echo a > a \
      && git add . \
      && git commit -am "add feature 1"
    } >/dev/null
    gla
    debug "echo 'feature1' | gf -v --yes"
    assert_equal $? 0
    gla
    assert_contains "$log" "Version history updated"
    assert_contains "${loglines[0]}" "(HEAD, dev) Merge branch 'myfeature' into dev"
    gref
    assert_equal "$(echo "$ref" | grep /refs/heads/myfeature)" ""
    changelog
    assert_equal "${chgloglines[0]}" "feature1"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "merge empty feature"; then
    { gf --init \
      && gf --yes myfeature
    } >/dev/null
    gla
    debug "gf -v --yes"
    assert_equal $? 1
    assert_startwith "${lines[0]}" "gf[error]: Nothing to merge"
  fi
#######################################
  if startTest "merge feature with rebase"; then
    { gf --init \
      && gf --yes myfeature \
      && echo a > a \
      && git add . \
      && git commit -am "add feature 1" \
      && git checkout dev \
      && echo c > c \
      && git add . \
      && git commit -am "bugfix 1"
    } >/dev/null 2>&1
    gla
    debug "echo 'feature1' | gf -v --yes myfeature"
    assert_equal $? 0
    gla
    assert_contains "$log" "Version history updated"
    assert_contains "${loglines[0]}" "(HEAD, dev) Merge branch 'myfeature' into dev"
    assert_contains "${loglines[5]}" "bugfix 1"
    gref
    assert_equal "$(echo "$ref" | grep /refs/heads/myfeature)" ""
    changelog
    assert_equal "${chgloglines[0]}" "feature1"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "merge feature with conflicting rebase"; then
    { gf --init \
      && gf --yes myfeature \
      && echo a > a \
      && git add . \
      && git commit -am "change file a" \
      && git checkout dev \
      && echo b > a \
      && git add . \
      && git commit -am "change file a"
    } >/dev/null 2>&1
    gla
    debug "echo 'feature1' | gf -v --yes myfeature"
    assert_equal $? 5
    gla
    gs
    assert_equal "$(gsp)" "AA a"
  fi
#######################################
  if startTest "merge feature with uncommited changes and --force"; then
    { gf --init \
      && gf --yes myfeature \
      && echo a > a \
      && git add . \
      && git commit -am "add feature 1" \
      && echo b > b
    } >/dev/null
    gla
    debug "echo 'feature1' | gf -v --yes --force"
    assert_equal $? 0
    assert_equal "${lines[0]}" "Stashing files"
    gla
    assert_contains "$log" "Version history updated"
    assert_contains "${loglines[0]}" "(HEAD, dev) Merge branch 'myfeature' into dev"
    gref
    assert_equal "$(echo "$ref" | grep /refs/heads/myfeature)" ""
    gs
    assert_equal "$(gsp)" "A  b"
  fi
#######################################
  # if startTest "merge feature with --request"; then
  #   { gf --init \
  #     && gf --yes myfeature \
  #     && echo a > a \
  #     && git add . \
  #     && git commit -am "add feature 1"
  #   } >/dev/null
  #   gla
  #   debug "echo 'feature1' | gf -v --yes --request"
  # fi
#######################################
# TODO: 7.h
#######################################
## RELEASE
#######################################
  if startTest "create release"; then
    { gf --init \
      && echo a > a \
      && git add . \
      && git commit -m "add file a"
    } >/dev/null
    gla
    debug "gf -v --yes"
    assert_equal $? 0
    gla
    assert_contains "${loglines[0]}" "Merge branch 'release' into dev"
    gref
    assert_contains "$ref" "refs/heads/release"
    assert_equal "$(cat VERSION)" "0.1.0"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "try create two releases"; then
    { gf --init \
      && echo a > a \
      && git add . \
      && git commit -m "add file a" \
      && gf --yes \
      && git checkout dev \
      && echo b > b \
      && git add . \
      && git commit -m "add file b"
    } >/dev/null 2>&1
    gla
    debug "gf -v --yes"
    assert_equal $? 1
    assert_equal "${lines[0]}" "gf[error]: Destination branch 'release' already exists"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "release with uncommited changes and --force"; then
    { gf --init \
      && echo a > a \
      && git add . \
      && git commit -m "add file a" \
      && echo b > b
    } >/dev/null
    gla
    debug "gf -v --yes --force"
    assert_equal $? 0
    assert_equal "${lines[0]}" "Stashing files"
    gla
    assert_contains "${loglines[0]}" "Merge branch 'release' into dev"
    gref
    assert_contains "$ref" "refs/heads/release"
    assert_equal "$(cat VERSION)" "0.1.0"
    gs
    assert_equal "$(gsp)" "A  b"
  fi
#######################################
  if startTest "release by kw"; then
    { gf --init \
      && echo a > a \
      && git add . \
      && git commit -m "add file a"
    } >/dev/null
    gla
    debug "gf -v --yes release"
    assert_equal $? 0
    gla
    assert_contains "${loglines[0]}" "(dev) Merge branch 'release' into dev"
    gref
    assert_contains "$ref" "refs/heads/release"
    assert_equal "$(cat VERSION)" "0.1.0"
    gs
    assert_equal "$(gsp)" ""
 fi
#######################################
  if startTest "merge release"; then
    { gf --init \
      && echo a > a \
      && git add . \
      && git commit -m "add file a" \
      && gf --yes
    } >/dev/null
    gla
    debug "gf -v --yes"
    assert_equal $? 0
    gla
    assert_contains "$log" "(HEAD, dev) Merge branch 'release' into dev"
    gref
    assert_equal "$(echo "$ref" | grep /refs/heads/release)" ""
    changelog
    assert_equal "${chgloglines[0]}" "0.1 | $(date '+%Y-%m-%d')"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "merge release with conflict"; then
    { gf --init \
      && echo a > a \
      && git add . \
      && git commit -m "add file a" \
      && gf --yes \
      && git checkout dev \
      && echo 1.0.0 > VERSION \
      && git commit -am "bump dev VERSION" \
      && git checkout release \
      && echo 2.0.0 > VERSION \
      && git commit -am "bump release VERSION"
    } >/dev/null 2>&1
    gla
    debug "gf -v --yes"
    assert_equal $? 5
    gla
    gs
    assert_equal "$(gsp)" "UU VERSION"
  fi
#######################################
  if startTest "merge release by kw"; then
    { gf --init \
      && echo a > a \
      && git add . \
      && git commit -m "add file a" \
      && gf --yes \
      && git checkout master
    } >/dev/null 2>&1
    gla
    debug "gf -v --yes release"
    assert_equal $? 0
    gla
    assert_contains "$log" "(HEAD, dev) Merge branch 'release' into dev"
    gref
    assert_equal "$(echo "$ref" | grep /refs/heads/release)" ""
    changelog
    assert_equal "${chgloglines[0]}" "0.1 | $(date '+%Y-%m-%d')"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "merge release with uncommited changes and --force"; then
    { gf --init \
      && echo a > a \
      && git add . \
      && git commit -m "add file a" \
      && gf --yes \
      && echo b > b
    } >/dev/null
    gla
    debug "gf -v --yes --force"
    assert_equal $? 0
    assert_equal "${lines[0]}" "Stashing files"
    gla
    assert_contains "${loglines[0]}" "Merge branch 'release'"
    gref
    assert_equal "$(cat VERSION)" "0.1.0"
    gs
    assert_equal "$(gsp)" "A  b"
  fi
#######################################
  # if startTest "merge release with --request"; then
  #   { gf --init \
  #     && gf --yes
  #   } >/dev/null
  #   gla
  #   debug "gf -v --yes --request"
  #   gla
  #   gs
  # fi
#######################################
# TODO: 8.i
#######################################
## HOTFIX
#######################################
  if startTest "hotfix master"; then
    { gf -i; } >/dev/null
    gla
    debug "gf -v --yes master"
    assert_equal $? 0
    gla
    assert_contains "${loglines[0]}" "(HEAD, hotfix-0.0.1) hotfix-0.0.1"
    assert_equal "$(cat VERSION)" "0.0.1"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "hotfix stable"; then
    { gf -i \
     && echo a > a \
     && git add . \
     && git commit -m "add file a" \
     && gf --yes \
     && gf --yes \
     && git checkout v0.0.0
    } >/dev/null 2>&1
    gla
    debug "gf -v --yes"
    assert_equal $? 0
    gla
    assert_contains "$log" "(HEAD, hotfix-0.0.1) hotfix-0.0.1"
    assert_equal "$(cat VERSION)" "0.0.1"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "hotfix master by kw"; then
    { gf -i \
      && git checkout dev
    } >/dev/null 2>&1
    gla
    debug "gf -v --yes hotfix"
    assert_equal $? 0
    gla
    assert_contains "${loglines[0]}" "(HEAD, hotfix-0.0.1) hotfix-0.0.1"
    assert_equal "$(cat VERSION)" "0.0.1"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "hotfix master by name of stable"; then
    { gf -i; } >/dev/null
    gla
    debug "gf -v --yes v0.0"
    assert_equal $? 0
    gla
    assert_contains "${loglines[0]}" "(HEAD, hotfix-0.0.1) hotfix-0.0.1"
    assert_equal "$(cat VERSION)" "0.0.1"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "hotfix stable by name of stable"; then
    { gf -i \
     && gf --yes \
     && gf --yes
    } >/dev/null 2>&1
    gla
    debug "gf -v --yes v0.0"
    assert_equal $? 0
    gla
    assert_contains "${loglines[0]}" "(HEAD, hotfix-0.0.1) hotfix-0.0.1"
    assert_equal "$(cat VERSION)" "0.0.1"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "hotfix master by tag name"; then
    { gf -i; } >/dev/null
    gla
    debug "gf -v --yes v0.0.0"
    assert_equal $? 0
    gla
    assert_contains "${loglines[0]}" "(HEAD, hotfix-0.0.1) hotfix-0.0.1"
    assert_equal "$(cat VERSION)" "0.0.1"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "hotfix stable by tag name"; then
    { gf -i \
     && gf --yes \
     && gf --yes
    } >/dev/null 2>&1
    gla
    debug "gf -v --yes v0.0.0"
    assert_equal $? 0
    gla
    assert_contains "${loglines[0]}" "(HEAD, hotfix-0.0.1) hotfix-0.0.1"
    assert_equal "$(cat VERSION)" "0.0.1"
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "hotfix master by old tag"; then
    { gf -i \
     && gf --yes hotfix \
     && gf --yes;
    } >/dev/null
    gla
    debug "gf -v --yes v0.0.0"
    assert_equal $? 1
    assert_equal "${lines[2]}" "gf[error]: Current branch is already hotfixed"
    gla
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "hotfix stable by old tag"; then
    { gf -i \
     && echo a > a \
     && git add . \
     && git commit -m "add file a" \
     && gf --yes \
     && gf --yes \
     && gf --yes v0.0.0 \
     && gf --yes; } >/dev/null
    gla
    debug "gf -v --yes v0.0.0"
    assert_equal $? 1
    assert_equal "${lines[2]}" "gf[error]: Current branch is already hotfixed"
    gla
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
# TODO: 9.f – 9.g
#######################################
  if startTest "merge master hotfix"; then
    { gf -i \
     && gf --yes master; } >/dev/null
    gla
    debug "gf -v --yes"
    assert_equal $? 0
    gla
    assert_contains "${loglines[0]}" "(HEAD, dev) Merge branch 'hotfix-0.0.1' into dev"
    assert_equal "$(cat VERSION)" "0.0.1"
    gref
    assert_equal "$(echo "$ref" | grep /refs/heads/hotfix-0.0.1)" ""
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "merge master hotfix by kw"; then
    { gf -i \
     && gf --yes master; } >/dev/null
    gla
    debug "gf -v --yes hotfix"
    assert_equal $? 0
    gla
    assert_contains "${loglines[0]}" "(HEAD, dev) Merge branch 'hotfix-0.0.1' into dev"
    assert_equal "$(cat VERSION)" "0.0.1"
    gref
    assert_equal "$(echo "$ref" | grep /refs/heads/hotfix-0.0.1)" ""
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
  if startTest "merge stable hotfix"; then
    { gf -i \
     && echo a > a \
     && git add . \
     && git commit -m "add file a" \
     && gf --yes \
     && gf --yes \
     && gf --yes v0.0.0; } >/dev/null
    gla
    debug "gf -v --yes"
    assert_equal $? 0
    gla
    assert_contains "$log" "(HEAD, tag: v0.0.1, v0.0) Merge branch 'hotfix-0.0.1' into v0.0"
    assert_equal "$(cat VERSION)" "0.0.1"
    gref
    assert_equal "$(echo "$ref" | grep /refs/heads/hotfix-0.0.1)" ""
    gs
    assert_equal "$(gsp)" ""
  fi
#######################################
# TODO: 9.i – 9.m
#######################################
# TODO: 10
#######################################


[[ $verbose == 1 ]] && clear
echo "$sep"
echo "Runned $runned of $i"
#echo "Failed: $failed"

[[ $failed == 0 ]] && return 0

}

main "$@"
